### Project Context: AMM Indexer and Telegram Bot

**Overall Goal:**
The project consists of two main components designed to index cryptocurrency swaps and display price data:

1.  **Indexer (`amm_indexer_prices`):** This service listens for swap events from two AMMs (SpikeySwap and DexlynSwap), processes them, and generates 1-minute OHLC (Open, High, Low, Close) price data.
2.  **Telegram Bot (`telegram-price-bot`):** This service allows users to query the OHLC price data generated by the indexer.

---

**Chosen Architecture:**
We have opted for a microservices architecture using two separate repositories and two databases to ensure a clean separation of concerns and system robustness.

-   **Repository 1: `amm_indexer_prices` (The Indexer - THIS REPO)**

    -   **Source Database (Local):** Utilizes **SQLite** to rapidly store raw swap data (`DexlynSwap`, `SpikeyAmmSwap`) and metadata (`Token`, `Pair`). This acts as a "hot" buffer.
    -   **Destination Database (Cloud):** Utilizes **Supabase (PostgreSQL)** to store the processed, consumption-ready data (`OhlcData`, along with a synchronized copy of `Token` and `Pair` tables).
    -   **Processing Logic:** A `TaskProcessor` cron job runs every minute, executing two tasks sequentially:
        1.  **DB Sync (`executeSyncDb`):** Synchronizes `Token` and `Pair` records from SQLite to Supabase. This process uses an **`upsert`** strategy based on **natural unique keys**, not auto-incrementing IDs. For `Token`, the key is its `address`. For `Pair`, the key is the combination of its two token addresses. This ensures data integrity without depending on matching IDs between databases.
        2.  **OHLC Aggregation (`executeOhlcAggregation`):** Reads the latest swaps from SQLite, calculates the 1-minute OHLC data, and saves the result to the `OhlcData` table in Supabase.

-   **Repository 2: `telegram-price-bot` (TO BE CREATED)**
    -   **Technology Stack:** To be built with **Node.js, TypeScript, and the Telegraf.js library**.
    -   **Database Connection:** The bot will connect **exclusively to the Supabase database** for read-only access. It will have no knowledge of the SQLite database.

---

### Guide for the Data Consumer (Telegram Bot)

This section is critical for the development of the `telegram-price-bot`. The bot must adhere to the following logic to query data correctly from the Supabase DB.

**Core Principle: Never Assume an ID.**
The auto-incrementing `id` for a `Token` or `Pair` in Supabase is an internal implementation detail and is **not** guaranteed to be stable or match any other system. All queries must start by finding records using their natural, business-logic keys.

**Required Query Flow for `/price <TOKEN_A>/<TOKEN_B>` command:**

1.  **Find Token IDs from Symbols:**

    -   Given user input like "SUPRA/USDC", first query the `Token` table in Supabase to find the records where `symbol` is 'SUPRA' and 'USDC'.
    -   This will give you the internal Supabase IDs for each token (e.g., `supraTokenId` and `usdcTokenId`).

2.  **Find Pair ID from Token IDs:**

    -   With the two token IDs from the previous step, query the `Pair` table.
    -   Use Prisma's compound unique key query to find the pair where `token0Id` and `token1Id` match the IDs you found. Note that you may need to test both orders (e.g., `(token0Id: supraTokenId, token1Id: usdcTokenId)` and `(token0Id: usdcTokenId, token1Id: supraTokenId)`) unless you enforce a consistent sort order in the bot.
    -   This query will give you the internal Supabase `id` for the correct pair.

3.  **Fetch OHLC Data:**
    -   Finally, with the `pairId` from step 2, you can query the `OhlcData` table to get all the price data for that pair, filtering by `pairId`.

By following this three-step process, the bot remains decoupled from the internal database IDs and will continue to function correctly even if the database is cleared, re-seeded, or migrated.

---

**Current Status & Next Steps:**

-   The work on the indexer repository (`amm_indexer_prices`) is logically complete and the data synchronization mechanism is now robust.
-   The next step is to create the `telegram-price-bot` repository and begin its implementation, following the data querying guide above